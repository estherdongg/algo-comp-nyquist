# Algorithmic Composition w/ Markov Chains and Sierpinski Triangle fractals

#### Our goal is generate harmonic progressions and melodies with a markov chain model based on predefined musical rules, while a fractal rhythm generator (implemented as a recursive sierpinski triangle) will determine note onsets and durations. This approach will blend probabilistic melody generation with self-similar rhythmic structures to produce evolving compositions

#### The final output should fulfill:
* Chords are determined by a Markov model
* Melody is generated by another Markov model
* Melody follows a fractal rhythmic structure
* Melody notes align with active chords (harmonic consistency)

[a good example of explaining fractal music](https://youtu.be/hEJy-PLyL1Q?si=7khxckP3NqrG-A5x)

## Implementation Ideas 

1. Manually define markov transition probabilities for melody and chords
2. Implement Markov Chain for Melody & Chord Generation
3. Implement Sierpinski Triangle for Rhythm Generation
4. Align Melody to Fractal Rhythm & Chords
5. Structure Everything (melody, rhythm, chords) into a Playable Format
6. Evaluation and Refinement



## Task Breakdown

### 1. **Data Collection**

#### What to Do: Define the scale/mode, chord progressions, and melodic contour rules using music theory


### Tasks:
#### 1) Choose a scale/mode and list the allowed notes
* `example: C major scale → C, D, E, F, G, A, B`

#### 2) Define a chord progressions
* `example for C Major: (II → V → I)  Dm → G7→ Cmaj7`
``` C
I → IV (40%), I → V (30%), I → vi (30%)
IV → I (50%), IV → V (50%)
V → I (100%)
```
#### 3) Assign allowed notes for each chord
* probably each chord gets a 5 note set ? root, third, fifth + tensions?
```
Cmaj7 → {C, E, G, B, D}
Fmaj7 → {F, A, C, E, G}
G7    → {G, B, D, F, A}
```

#### 4) Decide on melodic rules
* for example, if we are in C Major, a markov chain could prioritize stepwise motion (major 2nd, 3rd) while occasionally introducing a big interval leaps (7th)
* the melody should prioritize chord tones or available tensions of the chord

* Example Markov Transition Table (C Major)
```  C 
C → D (40%), C → E (30%), C → G (20%), C → A (10%)
D → E (50%), D → F (50%)
E → G (40%), E → C (30%), E → F (30%)
G → C (50%), G → E (30%), G → A (20%) 
```


### 2: **Implement Markov Chain for Melody & Chord Generation**

#### What to Do: Write Nyquist SAL functions to generate note sequences and chord progressions

### Tasks:

#### 1) Implement chord progression generator
* create a Nyquist list (or set of lists) that represents chord transitions with probability weights

#### 2) Random selection function: implement a helper function (e.g., weighted-random) to choose the next chord based on defined probabilities

#### 3) Chord Generator: Write a function to generate a chord sequence, create a function that starts from an initial chord and uses the transition probabilities to generate a chord sequence

#### 4) Implement Melody Generator
* create a Nyquist list (or set of lists) that represents note transitions with probability weights (using symbolic note names like 'C4', 'E4')

#### 5) Random selection function: implement a helper function (e.g., weighted-random) to choose the next note based on defined probabilities

#### 6) Melody Generator: Create a function that starts from an initial note and uses the transition probabilities to generate a melody sequence


### 3: **Implement Sierpinski Triangle for Rhythm Generation**

#### What to Do: Develop a recursive function to generate the fractal sequence, then map this sequence to rhythmic events

### Tasks:

#### 1) Recursive function: write a Nyquist SAL function sierpinski(n) that returns a list 

The pattern is recursively generated `(e.g., (1 0 1) for n = 1, etc.)` 
```
n = 1:  1 0 1  
n = 2:  1 0 1 0 0 0 1 0 1  
n = 3:  1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
```

#### 2) Rhythm mapping: create a function that converts the generated fractal sequence into a score (mapping 1 to a note and 0 to a rest) with a fixed time step (e.g., each step equals 0.5 seconds)


### 4: **Align Melody to Fractal Rhythm & Chords**

#### What to Do: Apply fractal rhythm to melody while ensuring melody fits chords

### Tasks:

#### 1) Apply the pattern to filter melody notes
* if pattern is 1, keep the melody note
* if pattern is 0, replace it with a rest

```C
Melody:   [C, D, E, G, B, A, F, D, E, G, A, C, F, D, G, B]
Rhythm:   [1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1]
Output:   [C, _, E, _, B, A, _, D, _, _, A, _, F, D, _, B]
```

#### 2) Align melody to chords
* assume chords change every 2 beats, check if each melody note belongs to the active chord
* if the note doesn’t belong to the chord, remap it to a valid chord tone (maybe with the nearest chord tone?

```c
Chord Progression: [Cmaj7 (2 beats), Fmaj7 (2 beats), G7 (2 beats)]
Melody:            [C, D, E, G, B, A, F, D]
Rhythm:            [1, 0, 1, 0, 1, 1, 0, 1]

Checking melody:
- C (valid for Cmaj7) → Keep
- D (not in Cmaj7) → Change to E
- E (valid for Cmaj7) → Keep
- G (valid for Cmaj7) → Keep
- B (valid for Cmaj7) → Keep
- A (not in Fmaj7) → Change to C
- F (valid for Fmaj7) → Keep
- D (not in G7) → Change to B

Final adjusted melody:
[C, E, E, G, B, C, F, B]
```

### 5: **Structure Everything (melody, rhythm, chords) into a Playable Format**

#### What to Do: Combine chords, melody, and rhythm into a structured score

#### 1) Create a final score (a list of note events) where each event includes a start time, duration, and note (from the markov chain output)

#### 2) Test playback with exec score-play(score) or exec timed-seq(score)


### 6: **Evaluation and Refinement**

#### What to Do: Evaluate and refine the generated compositions

### Tasks:

#### 1) Adjust the transition probabilities in the markov model to refine melodic progression

#### 2) Tweak the fractal parameters (e.g., recursion depth, time step) to balance note density and silence